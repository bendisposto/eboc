#lang scheme


(define iValue
  (interface () in equals notequals))

(define iNumber 
  (interface (iValue)
    geq leq lt gt
    plus minus mult div mod
    upto))

(define iSet
  (interface (iValue)
    contains))

(define Value%
  (class object%
    (super-new)
    
    (define/public (in x)
      (send x contains this))
    
    (define/public (notequals x)
      (not (send this equals x)))))

(define (number n)
  (new Number% [num n]))

;; This implements the class Number
(define Number%
  (class* Value%
    (iNumber)
    (super-new)
    
    (init-field num)
    
    (define (apply-to-number op b)
      (op num (send b get-num)))
    
    (define/public (get-num)
      num)
    
    ;; Relational Operators
    (define/public (equals b)
      (apply-to-number = b))
    
    (define/public (geq b)
      (apply-to-number >= b))
    
    (define/public (leq b)
      (apply-to-number <= b))
      
    (define/public (lt b)
      (apply-to-number < b))
    
    (define/public (gt b)
      (apply-to-number > b))
                   
    ;; Arithmetic Operators
    (define/public (plus b)
      ((compose number apply-to-number) + b))
    
    (define/public (mult b)
      ((compose number apply-to-number) * b))
    
    (define/public (div b)
      ((compose number apply-to-number) quotient b))
    
    (define/public (minus b)
      ((compose number apply-to-number) - b))
    
    (define/public (mod b)
      ((compose number apply-to-number) modulo b))
    
    ;; Set Operators
    (define/public (upto b)
      (implicit-set num (send b num)))))

(define (implicit-set a b)
  (new ImplicitSet% [min a] [max b]))

(define ImplicitSet%
  (class object%
    (init-field min)
    (init-field max)
    
    (super-new)
    
    (define/public (contains x)
      (and (eb<= min x) (eb<= x max)))
    
    (define/public (

(define (eb<= a b)
  (send a leq b))

(define (eb+ a b)
  (send a plus b))
  
(define (eb- a b)
  (send a minus b))

(define (eb* a b)
  (send a mult b))

(define (eb/ a b)
  (send a div b))

(define (ebmod a b)
  (send a mod b))

;; Definitions for Predicates
; existential quantifier

; implication

; conjunction

; equivalence

; true

; <=
(define (eb<= a b)
  (ebor (eb< a b)
        (eb= a b)))

; >
(define (eb> a b)
  (ebnot (eb<= a b)))

; >= 
(define (eb>= a b)
  (ebnot (eb< a b)))

; !=
(define (eb!= a b)
  (ebnot (eb= a b)))
        
; subseteq
(define (ebsubseteq x s)
  (ebin x (ebpow s)))

; subset
(define (ebsubset x s)
  (eband (eb!= x s)
         (ebsubseteq x s)))

; notin
(define (ebnotin x s)
  (ebnot (ebin x s)))

; not subseteq
(define (ebnotsubseteq x s)
  (ebnot (ebsubseteq x s)))

; not subset
(define (ebnotsubset x s)
  (ebnot (ebsubset x s)))

; Definitions for Expressions

; powerset1
(define (ebpow1 s)
  (ebsetminus (ebpow s)
              (make-empty-set)))

; inter

; union

; mod
(define (ebmod a b)
  (eb- a (eb* b (ebdiv a b))))

; ran
(define (ebran s)
  (ebinv (ebdom s)))

; relation
(define (ebrel s1 s2)
  (ebpow (ebtimes s1 s2)))

; surjective total relation <<->>
(define (ebstrel s1 s2)
  (ebinter (ebsrel s1 s2) (ebtrel s1 s2)))

; forward composition
(define (ebfcomp s1 s2)
  (ebbcomp s2 s1))

; domain restriction
(define (ebdres 
       