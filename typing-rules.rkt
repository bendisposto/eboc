#lang racket

(require "type-macros.rkt") 

(provide eventb-bin-expr-type-rules
         eventb-unary-expr-type-rules
         eventb-expr-quant-type-rules
         eventb-expr-lit-type-rules)
         
(typing-rules eventb-bin-expr-type-rules (e1.type e2.type)
              (rule (funimage) (a b)
                    ((e1.type == (P (a x b)))
                     (e2.type == a))
                    b)
              (rule (relimage) (a b)
                    ((e1.type == (P (a x b)))
                     (e2.type == (P a)))
                    (P b))
              (rule (mapsto) (a b)
                    ((e1.type == a)
                     (e2.type == b))
                    (a x b))
              (rule (rel trel srel strel pfun tfun pinj tinj psur tsur tbij) (a b)
                    ((e1.type == (P a))
                     (e2.type == (P b)))
                    (P (P (a x b))))
              (rule (bunion binter setminus) (a b)
                    ((e1.type == (P a))
                     (e2.type == (P a)))
                    (P a))
              (rule (cprod) (a b)
                    ((e1.type == (P a))
                     (e2.type == (P b)))
                    (P (a x b)))
              (rule (dprod) (a b c)
                    ((e1.type == (P (a x b)))
                     (e2.type == (P (a x c))))
                    (P (a x (b x c))))
              (rule (pprod) (a b c d)
                    ((e1.type == (P (a x c)))
                     (e2.type == (P (b x d))))
                    (P ((a x b) x (c x d))))
              (rule (bcomp) (a b c)
                    ((e1.type == (P (b x c)))
                     (e2.type == (P (a x b))))
                    (P (a x c)))
              (rule (fcomp) (a b c)
                    ((e1.type == (P (a x b)))
                     (e2.type == (P (b x c))))
                    (P (a x c)))
              (rule (ovl) (a b)
                    ((e1.type == (P (a x b)))
                     (e2.type == (P (a x b))))
                    (P (a x b)))
              (rule (domres domsub) (a b)
                    ((e1.type == (P a))
                     (e2.type == (P (a x b))))
                    (P (a x b)))
              (rule (ranres ransub) (a b)
                    ((e1.type == (P (a x b)))
                     (e2.type == (P b)))
                    (P (a x b)))
              (rule (upto) (a b)
                    ((e1.type == Z)
                     (e2.type == Z))
                    (P Z))
              (rule (plus minus mul div mod expn) ()
                    ((e1.type == Z)
                     (e2.type == Z))
                    Z))

(typing-rules eventb-unary-expr-type-rules (e.type)
             (rule (uminus) ()
                   ((e.type == Z))
                   Z)
             (rule (converse) (a b)
                   ((e.type == (P (a x b))))
                   (P (b x a)))
             (rule (card) (a)
                   ((e.type == (P a)))
                   Z)
             (rule (pow pow1) (a)
                   ((e.type == (P a)))
                   (P (P a)))
             (rule (union inter) (a)
                   ((e.type == (P (P a))))
                   (P a))
             (rule (dom) (a b)
                   ((e.type == (P (a x b))))
                   (P a))
             (rule (ran) (a b)
                   ((e.type == (P (a x b))))
                   (P b))
             (rule (min max) (a b)
                   ((e.type == (P Z)))
                   Z))

(typing-rules eventb-expr-quant-type-rules (e.type)
              (rule (qunion qinter) (a)
                    ((e.type == (P a)))
                    (P a))
              (rule (cset) (a)
                    ((e.type == a))
                    (P a)))

(typing-rules eventb-expr-lit-type-rules ()
             (rule (integer natural natural1) ()
                   ()
                   (P Z))
             (rule (pred succ) ()
                   ()
                   (P (Z x Z)))
             (rule (bool) ()
                   ()
                   (P B))
             (rule (true false) ()
                   () 
                   B)
             (rule (emptyset) (a)
                   ()
                   (P a))
             (rule (id) (a)
                   ()
                   (P (a x a)))
             (rule (prj1) (a b)
                   ()
                   (P ((a x b) x a)))
             (rule (prj2) (a b)
                   ()
                   (P ((a x b) x b))))